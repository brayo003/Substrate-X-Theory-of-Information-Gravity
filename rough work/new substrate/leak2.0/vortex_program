import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_bvp
from scipy.optimize import root_scalar

class SubstrateXVortex:
    def __init__(self, g=1.0, m_X=0.1, hbar=1.0, mass=1.0):
        self.g = g          # Self-interaction strength
        self.m_X = m_X      # Substrate mass parameter
        self.hbar = hbar
        self.mass = mass    # Particle mass in substrate
        
    def gross_pitaevskii_1d(self, r, psi):
        """1D radial GPE for vortex solutions"""
        psi_val, psi_prime = psi
        if r == 0:
            # Boundary condition at origin for vortex
            return [0.0, 0.0]
        
        # Vortex with winding number n
        n = 1  # Fundamental vortex
        
        # GPE with substrate potential
        dpsi_dr = psi_prime
        d2psi_dr2 = - (1/r) * psi_prime + (n**2/r**2)*psi_val + \
                    (2*self.mass/self.hbar**2) * (self.mu - self.g*abs(psi_val)**2 - \
                    self.m_X**2 * self.hbar**2/(2*self.mass)) * psi_val
        
        return [dpsi_dr, d2psi_dr2]
    
    def solve_vortex(self, R_max=20.0, n_points=1000, mu_guess=-0.1):
        """Solve for stationary vortex solution"""
        self.mu = mu_guess  # Chemical potential
        
        # Radial grid
        r = np.linspace(0, R_max, n_points)
        
        # Initial guess: vortex profile
        psi_guess = np.tanh(r)  # Approximate vortex shape
        dpsi_guess = 1.0/np.cosh(r)**2
        
        # Boundary conditions: psi(0)=0, psi(∞)=1
        def bc(ya, yb):
            return [ya[0], yb[0] - 1.0]  # psi(0)=0, psi(∞)=1
        
        # Solve BVP
        sol = solve_bvp(
            lambda r, y: self.gross_pitaevskii_1d(r, y),
            bc, r, [psi_guess, dpsi_guess]
        )
        
        if sol.success:
            return sol.x, sol.y[0], sol.y[1]
        else:
            # Try shooting method as fallback
            return self.solve_vortex_shooting(R_max, n_points)
    
    def solve_vortex_shooting(self, R_max=20.0, n_points=1000):
        """Shooting method for vortex solutions"""
        def vortex_derivatives(r, y, mu):
            psi, psi_prime = y
            if r == 0:
                return [0, 1.0]  # Regular at origin
            
            n = 1
            dpsi_dr = psi_prime
            d2psi_dr2 = - (1/r)*psi_prime + (n**2/r**2)*psi + \
                        (2*self.mass/self.hbar**2) * (mu - self.g*abs(psi)**2 - \
                        self.m_X**2 * self.hbar**2/(2*self.mass)) * psi
            return [dpsi_dr, d2psi_dr2]
        
        # Find chemical potential that gives psi(∞)=1
        def objective(mu):
            self.mu = mu
            r_span = [1e-6, R_max]
            sol = solve_ivp(
                lambda r, y: vortex_derivatives(r, y, mu),
                r_span, [0.0, 1.0], 
                t_eval=np.linspace(1e-6, R_max, n_points),
                rtol=1e-8
            )
            return sol.y[0][-1] - 1.0  # Want psi(R_max)=1
        
        # Find correct chemical potential
        mu_sol = root_scalar(objective, x0=-0.1, x1=-0.05)
        self.mu = mu_sol.root
        
        # Final solution
        r_span = [1e-6, R_max]
        sol = solve_ivp(
            lambda r, y: vortex_derivatives(r, y, self.mu),
            r_span, [0.0, 1.0], 
            t_eval=np.linspace(1e-6, R_max, n_points)
        )
        
        return sol.t, sol.y[0], sol.y[1]
    
    def compute_vortex_energy(self, r, psi, psi_prime):
        """Compute energy per vortex (→ particle mass)"""
        n = 1  # Winding number
        
        # Kinetic energy density
        kinetic_density = 0.5 * self.hbar**2/self.mass * (psi_prime**2 + (n**2/r**2)*psi**2)
        
        # Interaction energy density
        interaction_density = 0.5 * self.g * psi**4
        
        # Substrate potential energy
        substrate_density = 0.5 * self.m_X**2 * self.hbar**2 * psi**2
        
        # Total energy density
        energy_density = kinetic_density + interaction_density + substrate_density
        
        # Integrate to get total energy (mass)
        dr = r[1] - r[0]
        total_energy = 2 * np.pi * np.sum(energy_density[1:] * r[1:]) * dr
        
        return total_energy, energy_density
    
    def quantization_condition(self, r, psi):
        """Verify circulation quantization"""
        # Circulation around vortex: ∮v·dl = (h/m)n
        n = 1
        # Velocity field: v = (hbar/m) ∇θ = (hbar/m) (n/r)
        # Circulation = 2πr * v_theta = 2πr * (hbar n / (m r)) = 2π hbar n / m
        theoretical_circulation = 2 * np.pi * self.hbar * n / self.mass
        
        # Numerical verification at large r where psi→1
        v_theta = self.hbar * n / (self.mass * r[-1])
        numerical_circulation = 2 * np.pi * r[-1] * v_theta
        
        return theoretical_circulation, numerical_circulation

def compute_vortex_spectrum():
    """Compute mass spectrum for different parameters"""
    vortex_solver = SubstrateXVortex()
    
    # Parameter ranges
    g_values = [0.1, 0.5, 1.0, 2.0]
    m_X_values = [0.01, 0.1, 0.5, 1.0]
    
    results = []
    
    plt.figure(figsize=(15, 5))
    
    # Plot 1: Vortex profiles for different m_X
    plt.subplot(131)
    for m_X in [0.01, 0.1, 0.5]:
        vortex_solver.m_X = m_X
        r, psi, psi_prime = vortex_solver.solve_vortex()
        plt.plot(r, psi, label=f'm_X = {m_X}')
        plt.xlabel('r'); plt.ylabel('ψ(r)'); plt.legend()
        plt.title('Vortex Profiles')
    
    # Plot 2: Energy densities
    plt.subplot(132)
    vortex_solver.m_X = 0.1
    r, psi, psi_prime = vortex_solver.solve_vortex()
    energy, energy_density = vortex_solver.compute_vortex_energy(r, psi, psi_prime)
    
    plt.plot(r, energy_density, 'r-', label='Total energy density')
    plt.xlabel('r'); plt.ylabel('Energy density'); plt.legend()
    plt.title(f'Energy Density (E_total = {energy:.3f})')
    
    # Plot 3: Mass spectrum
    plt.subplot(133)
    masses = []
    for m_X in m_X_values:
        vortex_solver.m_X = m_X
        r, psi, psi_prime = vortex_solver.solve_vortex()
        energy, _ = vortex_solver.compute_vortex_energy(r, psi, psi_prime)
        masses.append(energy)
        
        # Verify quantization
        theory_circ, num_circ = vortex_solver.quantization_condition(r, psi)
        print(f"m_X = {m_X:.2f}: Energy = {energy:.4f}, Quantization error = {abs(theory_circ-num_circ)/theory_circ*100:.2f}%")
    
    plt.plot(m_X_values, masses, 'bo-')
    plt.xlabel('m_X'); plt.ylabel('Vortex Mass (Energy)')
    plt.title('Vortex Mass Spectrum')
    
    plt.tight_layout()
    plt.show()
    
    return masses

# Run vortex analysis
if __name__ == "__main__":
    print("=== SUBSTRATE X VORTEX (PARTICLE) PROGRAM ===")
    print("Solving Gross-Pitaevskii equation for vortex solutions...")
    
    masses = compute_vortex_spectrum()
    
    print("\n=== VORTEX MASS SPECTRUM ===")
    vortex_solver = SubstrateXVortex()
    m_X_test = [0.01, 0.05, 0.1, 0.5]
    for m_X in m_X_test:
        vortex_solver.m_X = m_X
        r, psi, psi_prime = vortex_solver.solve_vortex()
        energy, _ = vortex_solver.compute_vortex_energy(r, psi, psi_prime)
        print(f"m_X = {m_X:.2f} → Vortex mass = {energy:.4f} (natural units)")
